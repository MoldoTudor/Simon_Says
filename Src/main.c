/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>
#include "../stm32l476xx.h"
#include <stdbool.h>

bool ReadWhite()
{
	if (GPIOB->IDR & (1U << 2))
	{
		return true ;
	}
	else
	{
		return false ;
	}
}
bool ReadYellow()
{
	if (GPIOB->IDR & (1U << 1))
	{
		return true;
	}
	else
	{
		return false;
	}
}
bool ReadGreen()
{
	if (GPIOB->IDR & (1U << 15))
	{
		return true;
	}
	else
	{
		return false;
	}
}
bool ReadRed()
{
	if (GPIOB->IDR & (1U << 14))
	{
		return true;
	}
	else
	{
		return false;
	}
}
void OnLedRed(void)
{
	GPIOC-> BSRR = (1U << 7);
}

void OffLedRed(void)
{
	GPIOC-> BSRR = (1U << 23);
}
void OnLedYellow(void)
{
	GPIOC-> BSRR = (1U << 5);
}

void OffLedYellow(void)
{
	GPIOC-> BSRR = (1U << 21);
}
void OnLedGreen(void)
{
	GPIOC-> BSRR = (1U << 6);
}

void OffLedGreen(void)
{
	GPIOC-> BSRR = (1U << 22);
}
void OnLedWhite(void)
{
	GPIOC-> BSRR = (1U << 8);
}

void OffLedWhite(void)
{
	GPIOC-> BSRR = (1U << 24);
}

uint32_t sequence_modifier(uint32_t sequence , uint32_t color ,uint32_t location )
{
	uint32_t new_sequence ;
	new_sequence = sequence & ~(3U << (location*2));
	new_sequence = new_sequence | (color << (location*2));
	return new_sequence ;
}

void set_timer(void)
{
	SysTick->LOAD &= 0xFF000000 ;
	SysTick->LOAD |= 0x00030D3F ; // 50 ms
	SysTick->CTRL |= 1U;
	SysTick->CTRL |= (1U << 2);
	SysTick->CTRL &= ~(1U << 1);
	SysTick->VAL &= 0xFF000000 ;
	SysTick->VAL |= 0x00030D3F ; // 50 ms
}

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

bool timer_done(void)
{
	if(SysTick->CTRL & (1U << 16))
		return true;
	else
		return false;
}

int main(void)
{
        // 0b101( 5 binar )
		//uint32_t ( unsigned 32b int )

	    RCC->AHB2ENR |= (RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOCEN | RCC_AHB2ENR_GPIOBEN);

	    // setting for pins , 11 for output , 00 for input
	    GPIOC->MODER &= ~(3U << (7 * 2));
	    GPIOC->MODER |= (1U << (7 * 2));
	    GPIOC->MODER &= ~(3U << (5 * 2));
	    GPIOC->MODER |= (1U << (5 * 2));
	    GPIOC->MODER &= ~(3U << (6 * 2));
	    GPIOC->MODER |= (1U << (6 * 2));
	    GPIOC->MODER &= ~(3U << (8 * 2));
	    GPIOC->MODER |= (1U << (8 * 2));
	    GPIOB->MODER &= ~(3U << (2*2));
	    GPIOB->MODER &= ~(3U << (1*2));
	    GPIOB->MODER &= ~(3U << (15*2));
	    GPIOB->MODER &= ~(3U << (14*2));

	    uint32_t contor = 0;
	    uint32_t speed_on = 3 ;
	    uint32_t speed_off = 5;
	    uint32_t color = 5 ;
	    uint32_t max_turns = 5 ;
	    uint32_t current_turn = 0 ;
	    bool led_turn = 0 ;
	    bool game_start = 0;
	    bool player_turn = 0;
	    uint32_t sequence = 0;
	    uint32_t respond = 0;
	    uint32_t game_lost = 0;
	    uint32_t debounce_counter = 0;
	    uint32_t leds_on = 0;
	    uint32_t timer_leds = 0;



	    set_timer();
	    while(1)
	    {
	    	if((ReadWhite()||ReadYellow()||ReadGreen()||ReadRed())&&(game_start==0))
	    	{
	    		if(ReadWhite())
	    		{
	    			speed_on=12;
	    			speed_off=6;
	    			led_turn=1;
	    			game_start=1;
	    		}
	    		if(ReadYellow())
	    		{
	    			speed_on=10;
	    			speed_off=5;
	    			led_turn=1;
	    			game_start=1;
	    			contor=0;
	    		}
	    		if(ReadGreen())
	    		{
	    			speed_on=8;
	    			speed_off=4;
	    			led_turn=1;
	    			game_start=1;
	    		}
	    		if(ReadRed())
	    		{
	    			speed_on=6;
	    			speed_off=3;
	    			led_turn=1;
	    			game_start=1;
	    		}
	    	}
			while(led_turn==1)
			{
				if(current_turn==max_turns)
				{
					led_turn=0;
					current_turn=0;
					player_turn=1;
				}
				if(timer_done())
				{
					contor ++;
					if(contor==speed_on)
					{
						color=rand()%4;
						sequence=sequence_modifier(sequence,color,current_turn);
						switch(color)
						{
							case 0:OnLedWhite();
								   break;
							case 1:OnLedYellow();
								   break;
							case 2:OnLedGreen();
								   break;
							case 3:OnLedRed();
								   break;
						}
					}
					if(contor==speed_on+speed_off)
					{
						contor=0;
						switch(color)
						{
							case 0:OffLedWhite();
								   break;
							case 1:OffLedYellow();
								   break;
							case 2:OffLedGreen();
								   break;
							case 3:OffLedRed();
								   break;
						}
						current_turn++ ;
					}

				}

			}
			while(player_turn)
			{
				if(contor==max_turns)
				{
					contor=0;
					player_turn=0;
					game_start=0;
					sequence=0;
					while(timer_leds<10)
					{
						if(timer_done())
						{
							timer_leds++;
						}
					}
					OnLedWhite();
					timer_leds=0;
					while(timer_leds<10)
					{
						if(timer_done())
						{
							timer_leds++;
						}
					}
					OnLedYellow();
					timer_leds=0;

					while(timer_leds<10)
					{
						if(timer_done())
						{
							timer_leds++;
						}
					}

					OnLedGreen();
					timer_leds=0;

					while(timer_leds<10)
					{
						if(timer_done())
						{
							timer_leds++;
						}
					}

					OnLedRed();
					timer_leds=0;

				    while(leds_on<10)
				    {
				    	if(timer_done())
				    		leds_on++;
				    }
				    leds_on=0;
					OffLedWhite();
					OffLedYellow();
					OffLedGreen();
					OffLedRed();


				}
				if(ReadWhite()||ReadYellow()||ReadGreen()||ReadRed())
				{
					if(ReadWhite())
					{
						respond=0;
						OnLedWhite();
					}
					else if(ReadYellow())
					{
						respond=1;
						OnLedYellow();
					}
					else if(ReadGreen())
					{
						respond=2;
						OnLedGreen();
					}
					else if(ReadRed())
					{
						respond=3;
						OnLedRed();
					}
					while(ReadWhite()||ReadYellow()||ReadGreen()||ReadRed())
					{
					}
					while(debounce_counter<2)
					{
						if(timer_done())
							debounce_counter++;
					}
					debounce_counter=0;
					OffLedWhite();
					OffLedYellow();
					OffLedGreen();
					OffLedRed();
					if(((sequence >> contor* 2) & 3U)== respond )
					{
						contor ++ ;
					}
					else
					{
						OnLedWhite();
						OnLedYellow();
						OnLedGreen();
						OnLedRed();
						contor=0;
						player_turn=0;
						game_start=0;
						sequence=0;
						while(game_lost<20)
						{
							if(timer_done())
							{
								game_lost ++ ;
							}
						}
						OffLedWhite();
						OffLedYellow();
						OffLedGreen();
						OffLedRed();
						game_lost=0;
					}
				}
			}


	    }
	//	for(;;);
}
